<template>
  <div v-bind="applyStyleTokens({ componentDemo: true })">
    <DemoHeader
      :description="description"
      :styleTokens="styleTokens"
      :title="title"
    />

    <div>
      Usage
      import whatever from whatever
    </div>

    <div>
      <hr />
      <component
        v-if="'modelValue' in propsToDemo"
        v-model="demoProps.modelValue"
        :is="demo.component"
        v-bind="demoProps"
        v-on="demoEvents"
        :key="demo.component.name + '-v-model'"
      />
      <component
        v-else
        :is="demo.component"
        v-bind="demoProps"
        v-on="demoEvents"
        :key="demo.component.name + '-no-v-model'"
      />
      <hr />
    </div>

    <h3>Props Playground:</h3>

    <form v-bind="applyStyleTokens({ propsPlaygroundForm: true })">
      <component
        v-for="(prop, propName) in propsToDemo"
        v-model="demoProps[propName]"
        :is="prop.component"
        v-bind="prop.props"
        :key="propName"
      />
    </form>

    <CodeSwapper
      :javascript="js"
      :styleTokens="styleTokens"
      :vue="markup"
    />

    <h3>Props Documentation</h3>

    PropsDocumentation
    :component="demo.component"


    <h3>Emits Documentation</h3>

    EmitsDocumentation
    :component="demo.component"
    :emitsDocumentation="demo.emitsDocumentation"
  </div>
</template>

<script>
import _lowerFirst from 'lodash.lowerfirst';
import _startCase from 'lodash.startcase';

import {
  autoGeneratePlaygroundProps,
  createMarkupExample,
  deJSONify
} from '@/helpers/demoHelpers.js';
import { styleTokens } from '@/helpers/props.js';

import applyStyleTokens from '@/mixins/applyStyleTokensMixin.js';

import CodeSwapper from '@/components/CodeSwapper.vue';
import DemoHeader from '@/components/DemoHeader.vue';

/*
import CodeBox from '@/components/CodeBox.vue';
import EmitsDocumentation from '@/components/EmitsDocumentation.vue';
import PropsDocumentation from '@/components/PropsDocumentation.vue';
*/

export default {
  name: 'DoxenComponentDemo',
  components: {
    CodeSwapper,
    DemoHeader
  },
  mixins: [applyStyleTokens],
  props: {
    demo: {
      type: Object,
      required: true
    },
    styleTokens
  },
  data: function () {
    return {
      demoProps: {}
    };
  },
  methods: {
    initializePlayground: function () {
      for (const propName in this.propsToDemo) {
        this.demoProps[propName] = this.propsToDemo?.[propName]?.props?.modelValue;
      }
    }
  },
  computed: {
    title: function () {
      return _startCase(this.demo?.component?.name);
    },
    description: function () {
      return (
        this.demo?.description ||
        this.demo?.component?.description
      );
    },
    propsToDemo: function () {
      const actualProps = this.demo?.component?.props;
      const autoGeneratedPlaygroundProps = autoGeneratePlaygroundProps(actualProps, this.styleTokens);
      const propsToDemo = this.demo?.propsToDemo;
      const playgroundProps = {
        ...propsToDemo
      };
      for (const propName in actualProps) {
        const alreadyDefined = propName in playgroundProps;
        if (!alreadyDefined) {
          playgroundProps[propName] = autoGeneratedPlaygroundProps[propName];
        }
      }

      return playgroundProps;
    },
    demoEvents: function () {
      const events = {};
      this.demo?.emitsDocumentation?.forEach((emitDetails) => {
        const emit = emitDetails.name;
        events[emit] = ($event, value) => {
          this.propsPlayground.emit.push({ emit, $event, value });
          // Intentional console log to demonstrate emits
          console.log(this.title + ' emit log:', { emit, $event, value });
        };
      });
      return events;
    },
    markup: function () {
      const tag = this.demo?.component?.name || '';
      const emits = this.demo?.component?.emits || [];
      const attributes = Object.keys(this.propsToDemo)
        .map((propName) => {
          return {
            name: propName,
            value: this.demoProps[propName],
            required: !!this.demo?.component?.props?.[propName]?.required
          };
        });
      const slot = undefined; // this.propsPlayground?.slot;
      return createMarkupExample(tag, attributes, slot, emits);
    },
    js: function () {
      const propsOutput = {};
      const tag = _lowerFirst(this.demo?.component?.name || '');
      // Process Props
      Object.keys(this.propsToDemo)
        .forEach((propName) => {
          const value = this.demoProps[propName];
          const defaultValue = this.demo?.component?.props?.[propName]?.default;
          if (
            typeof(value) === 'boolean' &&
            typeof(defaultValue) === 'boolean' &&
            defaultValue === value
          ) {
            return;
          } else if (![undefined, null, ''].includes(value)) {
            propsOutput[propName] = value;
          }
        });

      // propsOutput.innerHTML = this.propsPlayground?.slot;
      const propsJs = 'const ' + tag + 'Props = ' + deJSONify(propsOutput, '\n') + ';';

      return propsJs;
      /*
      const indent = '\n  ';
      const emits = this.demo?.emitsDocumentation || [];
      const emitStrings = emits
        .filter(Boolean)
        .map(function (emit) {
          const indent = '  ';
          return [
            emit.name + ': function ($event, value) {',
            indent + indent + 'console.log($event, value);',
            indent + '}'
          ].join('\n');
        });
      const eventsOutput = '{' + indent + emitStrings.join(',' + indent) + '\n}';
      const eventsJs = 'const ' + tag + 'Events = ' + eventsOutput + ';';
      if (!emits.length) {
        return propsJs;
      }
      return [propsJs, eventsJs].join('\n');
      */
    }
  },
  created: function () {
    this.initializePlayground();
  }
};
</script>
